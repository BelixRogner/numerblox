# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/07_evaluation.ipynb (unless otherwise specified).

__all__ = ['BaseEvaluator', 'NumeraiClassicEvaluator', 'NumeraiSignalsEvaluator']

# Cell
import numpy as np
import pandas as pd
from typing import Tuple
from abc import ABC, abstractmethod

from .dataset import Dataset, create_dataset
from .postprocessing import FeatureNeutralizer

# Cell
class BaseEvaluator(ABC):
    def __init__(self, era_col: str = "era"):
        self.era_col = era_col

    def full_evaluation(self, dataset: Dataset) -> Tuple[pd.DataFrame, pd.DataFrame]:
        validation_stats = pd.DataFrame()
        validations_by_era = pd.DataFrame()

        for pred_col, target_col in zip(dataset.prediction_cols, dataset.target_cols):
            self.evaluation_one_col(dataset=dataset,
                                    pred_col=pred_col,
                                    target_col=target_col)
        return validation_stats, validations_by_era

    @abstractmethod
    def evaluation_one_col(self, dataset: Dataset, pred_col: str, target_col: str):
        val_corrs = self._per_era_corrs(dataf=dataset.dataf,
                                        pred_col=pred_col,
                                        target_col=target_col)

    def _tb200(self, ):
        ...

    def _mean_std_sharpe(self, ):
        ...

    def _max_drawdown(self, ):
        ...

    def _mmc(self, ):
        ...

    def _apy(self, ):
        ...

    def _max_feature_exposure(self):
        ...

    def _example_correlation(self, dataset: Dataset,
                             pred_col: str, example_col: str):
        """ Get correlations with example predictions. """
        return self._per_era_corrs(dataf=dataset.dataf,
                                   pred_col=pred_col,
                                   target_col=example_col,
                                   ).mean()

    def _per_era_corrs(self, dataf: pd.DataFrame, pred_col: str,
                       target_col: str):
        """ Correlation between prediction and target for each era. """
        return dataf.groupby(dataf[self.era_col])\
            .apply(lambda d: self._normalize_uniform(d[pred_col])
                   .corr(self._normalize_uniform(d[target_col])))

    @staticmethod
    def feature_neutral_mean(dataset: Dataset, pred_col: str) -> np.float64:
        fn = FeatureNeutralizer(pred_name=pred_col,
                                proportion=1.0)
        neutralized_dataset = fn.transform(dataset=dataset)
        return neutralized_dataset[fn.final_col_name].mean()

    @staticmethod
    def _normalize_uniform(df: pd.DataFrame) -> pd.Series:
        x = (df.rank(method="first") - 0.5) / len(df)
        return pd.Series(x, index=df.index)


# Cell
class NumeraiClassicEvaluator(BaseEvaluator):
    def __init__(self):
        super().__init__()

# Cell
class NumeraiSignalsEvaluator(BaseEvaluator):
    def __init__(self):
        super().__init__()