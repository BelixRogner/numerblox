# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_download.ipynb (unless otherwise specified).

__all__ = ['BaseDownloader', 'NumeraiClassicDownloader']

# Cell
import os
import json
import shutil
from numerapi import NumerAPI, SignalsAPI
from pathlib import Path, PosixPath
from abc import ABC
from rich.tree import Tree
from rich.console import Console
from rich import print as rich_print

# Cell
class BaseDownloader(ABC):
    """
    Abstract base class for downloaders.
    :param directory_path: Base directory where data will be saved.
    """
    def __init__(self, directory_path: str):
        self.dir = Path(directory_path)
        if not self.dir.is_dir():
            rich_print(f"No existing directory found at '[blue]{self.dir}[/blue]'. Creating directory...")
            self.dir.mkdir(parents=True, exist_ok=True)

    def download_training_data(self, *args, **kwargs):
        """ Download all necessary files needed for training. """
        raise NotImplementedError(f"No method for downloading training data is implemented in '{self.__class__.__name__}'")

    def download_inference_data(self, *args, **kwargs):
        """ Download minimal amount of files needed for weekly inference. """
        raise NotImplementedError(f"No method for downloading inference data is implemented in '{self.__class__.__name__}'.")

    def remove_base_directory(self):
        """ Remove download directory with all contents. """
        abs_path = self.dir.resolve()
        rich_print(f":warning: [red]Deleting directory for '{self.__class__.__name__}[/red]' :warning:\nPath: '{abs_path}'")
        shutil.rmtree(abs_path)

    def _append_folder(self, folder: str) -> Path:
        """
        Return base directory appended with 'folder'.
        Create directory if it does not exist.
        """
        dir = Path(self.dir / folder)
        dir.mkdir(parents=True, exist_ok=True)
        return dir

    @staticmethod
    def _load_json(file_path: str, verbose = False, *args, **kwargs) -> dict:
        """ Load JSON from file and return as dictionary. """
        with open(file_path) as json_file:
            json_data = json.load(json_file, *args, **kwargs)
        if verbose:
            rich_print(json_data)
        return json_data

    @property
    def get_all_files(self) -> list:
        """ Return all contents in directory. """
        return list(self.dir.iterdir())

    @property
    def is_empty(self) -> bool:
        """ Check if directory is empty."""
        return not bool(self.get_all_files)

    def __call__(self, *args, **kwargs):
        """
        The most common use case will be to get weekly inference data. So calling the class itself returns inference data.
        """
        self.download_inference_data(*args, **kwargs)

# Cell
class NumeraiClassicDownloader(BaseDownloader):
    """
    Downloading from NumerAPI for Numerai Classic data

    :param directory_path: Main folder to download data in.
    All *args, **kwargs will be passed to NumerAPI initialization.
    """
    def __init__(self, directory_path: str, *args, **kwargs):
        super(NumeraiClassicDownloader, self).__init__(directory_path=directory_path)
        self.napi = NumerAPI(*args, **kwargs)
        self.current_round = self.napi.get_current_round()

    def download_training_data(self, folder: str = "", version: int = 2, int8: bool = False):
        """
        Get Numerai classic training and validation data.
        :param folder: Specify folder to create folder within directory root. Saves in directory root by default.
        :param version: Numerai version (1=classic, 2=super massive dataset (parquet)
        :param int8: Integer version of data
        """
        dir = self._append_folder(folder)
        if int8:
            version_mapping = {1: ['numerai_training_data_int8.csv', 'numerai_validation_data_int8.csv'],
                               2: ['numerai_training_data_int8.parquet', 'numerai_validation_data_int8.parquet']
                               }
        else:
            version_mapping = {1: ['numerai_training_data.csv', 'numerai_validation_data.csv'],
                               2: ['numerai_training_data.parquet', 'numerai_validation_data.parquet']
                               }
        train_val_files = self._get_version_mapping(version_mapping, version)
        for file in train_val_files:
            self.download_single_dataset(filename=file,
                                         dest_path=str(dir.joinpath(file)))


    def download_inference_data(self, folder: str = "", version: int = 2, int8: bool = False, round_num: int = None):
        """
        Get Numerai classic inference data.
        :param folder: Specify folder to create folder within directory root. Saves in directory root by default.
        :param version: Numerai version (1=classic, 2=super massive dataset (parquet)
        :param int8: Integer version of data
        :param round_num: Numerai tournament round number. Downloads latest round by default.
        """
        dir = self._append_folder(folder)
        if int8:
            version_mapping = {1: ['numerai_tournament_data_int8.csv'],
                               2: ['numerai_tournament_data_int8.parquet']
                               }
        else:
            version_mapping = {1: ['numerai_tournament_data.csv'],
                               2: ['numerai_tournament_data.parquet']
                               }
        train_val_files = self._get_version_mapping(version_mapping, version)
        rich_print(f":file_folder: [green]Downloading inference data for round[/green] '{round_num if round_num else self.current_round}'.")
        for file in train_val_files:
            self.download_single_dataset(filename=file,
                                         dest_path=str(dir.joinpath(file)),
                                         round_num=round_num)

    def download_single_dataset(self, filename: str, dest_path: str, round_num: int = None):
        """
        Download one of the available datasets through NumerAPI.

        :param filename: Name as listed in NumerAPI (Check NumerAPI().list_datasets())
        :param dest_path: Full path where file will be saved.
        :param round_num: Numerai tournament round number. Downloads latest round by default.
        """
        assert filename in self.napi.list_datasets(), f"Dataset '{filename}' not available in NumerAPI. Available datasets are {self.napi.list_datasets()}."
        rich_print(f":file_folder: [green]Downloading[/green] '{filename}' :file_folder:")
        self.napi.download_dataset(filename=filename,
                                   dest_path=dest_path,
                                   round_num=round_num)


    def download_example_data(self, folder: str = "", version: int = 2, round_num: int = None):
        """
        Download all example prediction data in specified folder for given version.

        :param folder: Specify folder to create folder within directory root. Saves in directory root by default.
        :param version: Numerai version (1=classic, 2=super massive dataset (parquet)
        :param round_num: Numerai tournament round number. Downloads latest round by default.
        """
        dir = self._append_folder(folder)
        version_mapping = {1: ['example_predictions.csv', 'example_validation_predictions.csv'],
                           2: ['example_predictions.parquet', 'example_validation_predictions.parquet']
                           }
        example_files = self._get_version_mapping(version_mapping, version)
        for file in example_files:
            self.download_single_dataset(filename=file,
                                         dest_path=str(dir.joinpath(file)),
                                         round_num=round_num)

    def get_classic_features(self, folder: str = "", *args, **kwargs) -> dict:
        """
        Download feature overview (stats and feature sets) through NumerAPI and load.
        :param folder: Specify folder to create folder within directory root. Saves in directory root by default.
        *args, **kwargs will be passed to the JSON loader
        """
        dir = self._append_folder(folder)
        filename = "features.json"
        dest_path = str(dir.joinpath(filename))
        self.download_single_dataset(filename=filename,
                                     dest_path=dest_path)
        # Load in json
        json_data = self._load_json(dest_path, *args, **kwargs)
        return json_data

    @staticmethod
    def _get_version_mapping(version_mapping: dict, version: int) -> list:
        """ Check if version is supported and return files corresponding to version mapping """
        try:
            files = version_mapping[version]
        except KeyError:
            raise NotImplementedError(f"Version '{version}' is not implemented. Available versions are {list(version_mapping.keys())}")
        return files